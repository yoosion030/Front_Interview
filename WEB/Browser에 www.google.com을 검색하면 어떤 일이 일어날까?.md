# Browser에 www.google.com을 검색하면 어떤 일이 일어나나요??

### 도메인과 DNS

++ 우리가 google 사이트에 접속하고 싶다면 해당 사이트의 **IP주소**를 알아야 한다.
근데 한눈에 파악하기 힘든 IP주소를 어떻게 어떻게 하나하나 외울 것인가? 그래서 나온 것이 도메인과 DNS 이다.

```
172.217.175.14
```

이렇게 외우기 힘든 주소를

```
google.com
```

로 외우기 쉽게 **IP주소를 대신하는 주소**가 도메인이다.

DNS(Domain Name System)는 도메인 주소와 IP 주소를 매칭시키는 시스템이다.

DNS는 도메인 주소와 IP 주소를 저장하고 있는 데이터 베이스이다.
DNS 서버는 간단히 보아 `google.com`을 검색했을 때 도메인에 일치한 IP주소를 찾는 역할을 한다.

## 1. www.google.com을 브라우저 주소창에 친다.

## 2. 브라우저는 캐싱된 DNS 기록들을 통해 www.google.com에 대응되는 IP 주소가 있는지 확인한다.

도메인 주소를 브라우저에 검색하면 브라우저는 DNS 기록을 4가지의 캐시에서 확인을 한다.

1. **브라우저 캐시**를 확인한다. 브라우저는 일정기간 동안 DNS 기록들을 저장하고 있다. DNS query가 이 곳에서 가장 먼저 실행이 된다.
2. 브라우저는 **OS 캐시**를 확인한다. 브라우저 캐시에 검색한 도메인과 IP 주소가 발견되지 않았다면, 브라우저는 systemcall을 통해서 OS가 저장하고 있는 DNS기록들을 캐시에 접근한다.
3. **router 캐시**를 확인한다. 컴퓨터에 DNS 기록을 찾지 못하면 브라우저는 DNS 기록을 캐싱하고 있는 router와 통신해서 찾으려고 한다.
4. 그래도 못 찾는다면 마지막으로 **ISP 캐시**를 확인한다. ISP는 DNS 서버를 구축하고 있고 브라우저가 마지막으로 DNS 기록이 있기를 바라며 접근하게 된다.

개인정보를 생각했을 때 정보가 여기저기에 캐싱된게 조금 불편할 수 있겠지만, 캐시는 네트워크 트래픽을 조절하고 데이터 전송 시간을 줄이기 위해 매우 중요하다.

브라우저 캐시 -> OS 캐시 -> router 캐시 -> ISP 캐시

## 3. 요청한 URL이 캐시에 없으면, ISP의 DNS 서버가 www. google.com을 오스팅 하고 있는 서버의 IP 주소를 찾기 위해 DNS query를 날린다.

DNS query의 목적은 **여러 다른 DNS 서버들을 검색해서 해당 사이트의 IP 주소를 찾는 것**이다. 이러한 검색을 `recursive search`라고 부른다.
요청한 URL이 캐시에 저장되어 있지 않았다면, IP 주소를 찾을 때 까지 DNS 서버에서 다른 DNS 서버를 오가면서 반복적으로 검색하던지 못 찾아서 에러가 발생할 때 까지 검색을 진행한다.

이 상황에서, ISP의 DNS 서버를 `DNS recursor`라고 부르고 인터넷을 통해 다른 DNS 서버들에게 물어 물어 도메인 이름의 올바른 IP 주소를 찾는데 책임을 갖고 있다. 다른 DNS 서버들은 `name server`라고 불린다. 이들은 웹사이트 도메인 이름의 구조에 기반해서 검색을 하기때문이다.

우리가 마주하는 웹사이트 URL들은 third-level domain, second-level domain, top-level domain을 가지고 있다. 각 레벨별로 자신들만의 **name 서버**가 있고 여기서 DNS look up 프로세스 중에 쿼리가 진행된다.

1. 웹 브라우저는 해결사 서버에게 요청한다.
   “www.hanamon.kr의 IP 주소를 알려주세요.”
2. 해결사 서버는 최상위 기관에서 관리하는 네임 서버에게 요청한다.
   ”.kr 이라는 도메인 있나요?”
3. 최상위 기관에서 관리하는 네임 서버는 응답한다.
   “.kr 한국 국가 도메인 입니다. .kr 네임 서버로 가보세요~”
4. 해결사 서버는 이제는 .kr 네임 서버에게 요청한다.
   “hanamon.kr 있나요?”
5. .kr 네임 서버는 응답한다.
   “네 가비아로 가세요~”
   (”hakunamatata.kr 있나요?” 라고 물어봐도 “네 가비아로 가세요~”라고 응답한다.)
6. 해결사 서버는 가비아 네임 서버에게 요청한다.
   “www.hanamon.kr 있나요?”
7. 가비아 네임 서버는 응답한다.
   네 12.345.678.900 으로 가세요!”
8. 해결사 서버는 웹 브라우저에게 알려준다.
   네 12.345.678.900 으로 가세요!”

이 모든 요청들은 **작은 데이터 패킷**들을 통해서 보내진다. 패킷 안에는 보내는 요청의 내용과 `DNS recursor의 IP 주소`가 포함되어 있다. 이 패킷들은 원하는 DNS 기록을 가진 DNS 서버에 도달할 때 까지 클라이언트와 서버를 여러번 오간다. 패킷들이 움직이는 것도 routing table에 기반한다. Routing table을 통해서 어떤 길로 가야 가장 빠른지 확인할 수 있다. 만약 패킷이 도중에 loss되면 request fail error가 발생하게 된다.

## 4. Browser가 서버와 TCP connection을 한다.

브라우저가 올바른 IP 주소를 받게 되면 서버와 connection을 빌드하게 된다. 브라우저는 인터넷 프로토콜을 사용해서 서버와 연결이 된다. 인터넷 프로토콜의 종류는 여러가지가 있지만, **웹사이트의 HTTP 요청의 경우에는 일반적으로 TCP를 사용한다.**

## 5. Browser가 웹 서버에 HTTP 요청을 한다.

TCP로 연결이 되었다면, 데이터를 전송하면 된다.

브라우저는 GET 요청을 통해 www.google.com 웹페이지를 요구한다. 요청을 할 때 비밀 자료들을 포함하던지, form을 제출하는 상황에서는 POST 요청을 사용할 수도 있다. 이 요청을 할 때 다른 부가적인 정보들도 함께 전달이 된다.

- browser identification(User-Agent 헤더)
- 받아들일 요청의 종류(Accept 헤더)
- 추가적인 요청을 위해 TCP connection을 유지를 요청하는 connection 헤더
- 브라우저에서 얻은 쿠키 정보
- 기타 등등

## 6. 서버가 요청을 처리하고 response를 생성한다.

서버가 브라우저로 부터 요청을 읽고 response를 생성하게 된다. 요청으로 온 헤더, 쿠키를 읽어 요청이 무엇인지 파악하고 필요하다면 서버에 정보를 업데이트 한다. response를 특정한 포맷으로(JSON, XML, HTML) 작성한다.

## 7. 서버가 HTTP response를 보낸다.

브라우저에게 생성한 response를 보낸다.

## 8. Browser가 HTML content를 보여준다.

브라우저는 HTML content를 단계적으로 보여준다. 그토록 원했던 www.google.com의 모습이 보이게 된다.

www.google.com을 검색하고 웹페이지가 뜰 때까지 엄청 많은 일들이 일어나지만, 이 모든 일들이 1초도 되지 않아서 완료가 된다.
